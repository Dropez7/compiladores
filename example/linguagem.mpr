Você tem toda a razão! Peço desculpas. Na tentativa de organizar o código, deixei o wheeldecide de fora e não dei a devida atenção a todas as construções que você implementou.

Eu revisei seu sintatico.y do início ao fim, com muita atenção, para entender TUDO o que você fez. Sua linguagem é muito mais rica do que os exemplos anteriores demonstravam. Você tem trocas de variáveis, bind para métodos, laços do-wd, e outras construções únicas.

Criei um novo arquivo de exemplo do zero. Desta vez, ele é um verdadeiro "tour" por todos os recursos que a sua gramática suporta, na ordem mais lógica possível, com explicações para cada um. Este é o arquivo definitivo para testar e demonstrar seu compilador.

Arquivo de Demonstração Completo e Definitivo da Linguagem
// ===================================================================
//   Arquivo de Demonstração Definitivo da Linguagem MAPHRA
//
// Este código foi reescrito do zero para demonstrar CADA recurso
// presente no arquivo sintatico.y, usando a sintaxe correta do lex.l.
// ===================================================================


// --- 1. Definições Globais: Structs e Variáveis ---

// Definição de structs, incluindo aninhamento.
struct Ponto {
    float x;
    float y;
}

struct Retangulo {
    Ponto superior_esquerdo;
    Ponto inferior_direito;
    string nome;
}

// Uma struct para demonstrar o bind de métodos.
struct Circulo {
    float raio;
}

// Variável de escopo global.
int id_global = 100;


// --- 2. Funções e Métodos ---

// Procedimento (retorno void implícito) com struct como parâmetro.
func imprimirPonto(Ponto p) {
    print("Ponto(x:", p.x, ", y:", p.y, ")");
}

// Função com retorno explícito.
func calcularAreaRetangulo(Retangulo r) : float {
    float base = r.inferior_direito.x - r.superior_esquerdo.x;
    float altura = r.superior_esquerdo.y - r.inferior_direito.y;
    return base * altura;
}

// Método "vinculado" (bind) à struct Circulo.
// O 'this' é usado para se referir à instância do objeto.
bind Circulo area() : float {
    return 3.14159 * this.raio * this.raio;
}


// --- 3. Função Principal ---
func main() {

    print("--- INÍCIO DA EXECUÇÃO ---");
    
    // --- 3.1. Tipos, Declarações e I/O ---
    print("\n--- Seção 1: Tipos, Declarações e I/O ---");
    
    // Declaração explícita de todos os tipos primitivos.
    int idade = 30;
    float pi_aprox = 3.14;
    bool compilador_legal = T;
    string mensagem = "Olá, Mundo!";
    
    print("Valores Iniciais -> Idade:", idade, "PI:", pi_aprox, "Legal?:", compilador_legal);
    print(mensagem);
    
    // Declaração implícita (infere o tipo).
    variavel_nova = 2025;
    print("Ano (declarado implicitamente):", variavel_nova);

    // Entrada do usuário.
    string nome_usuario = input("Digite seu nome: ");
    print("Bem-vindo,", nome_usuario, "!");


    // --- 3.2. Operadores e Expressões ---
    print("\n--- Seção 2: Operadores e Expressões ---");
    
    // Aritméticos
    int soma = idade + 5;
    float divisao = 100.0 / 3.0;
    print("Soma:", soma, "| Divisão:", divisao);
    
    // Lógicos: ^ (AND), ? (OR), ~ (NOT)
    if ((idade > 18 ^ compilador_legal) ? F) {
        print("Esta mensagem não deve aparecer.");
    } else {
        print("Expressão lógica (AND, OR) funcionando!");
    }
    
    // Relacionais
    if (10 != 20) { print("10 é diferente de 20."); }
    
    // Unários e Abrebiados
    idade++;
    print("Idade incrementada:", idade);
    idade += 9; // idade = 31 + 9 = 40
    print("Idade com atribuição abreviada:", idade);
    
    // Troca de variáveis (sintaxe especial)
    int a = 10;
    int b = 99;
    print("Antes da troca: a =", a, ", b =", b);
    a, b = b, a;
    print("Depois da troca: a =", a, ", b =", b);

    // Cast (Conversão Explícita de Tipo)
    int pi_inteiro = int(pi_aprox);
    print("PI convertido para inteiro:", pi_inteiro);


    // --- 3.3. Estruturas de Controle de Fluxo ---
    print("\n--- Seção 3: Estruturas de Controle ---");

    // if / else
    if (a < b) { print("Agora 'a' é menor que 'b'."); }

    // switch / option / default
    switch(a) {
        option 10: print("Switch: 'a' é 10."); break;
        option 99: print("Switch: 'a' é 99."); break;
        default: print("Switch: valor de 'a' não esperado.");
    }

    // Laço 'for' (estilo C) com break e continue
    print("Laço 'for' de 0 a 9:");
    for (int i = 0; i < 10; i++) {
        if (i % 4 == 0) { continue; } // Pula múltiplos de 4
        print(i);
        if (i == 7) { break; } // Para no 7
    }

    // Laço 'for' (estilo while)
    print("Laço estilo 'while' (contagem regressiva):");
    int j = 3;
    for (j > 0) {
        print(j);
        j--;
    }

    // Laço 'do-for' (estilo do-while)
    print("Laço 'do-for':");
    int k = 0;
    do {
        print("Executou o DO pelo menos uma vez!");
        k++;
    } for (k < 1);

    // Laco 'for' com iterador (usando 'in')
    string palavras[];
    palavras.append("Compilador");
    palavras.append("é");
    palavras.append("legal");

    for (string p in palavras) {
        print(p);
    }

    // Operador Ternário (if-else inline)
    int idade = 21;
    
    string status = "Maior de idade" if idade >= 18 else "Menor de idade";
    print("Status:", status);
    
    int valor = 100 if status == "Maior de idade" else 50;
    print("Valor a ser pago:", valor);

    print("A pessoa é " + ("adulta" if idade >= 18 else "jovem") + ".");
    

    // --- 3.4. Structs, Vetores e Métodos ---
    print("\n--- Seção 4: Structs, Vetores e Métodos ---");
    
    // Instanciando e usando structs
    Ponto p_origem;
    p_origem.x = 0.0;
    p_origem.y = 0.0;
    
    Retangulo r_teste;
    r_teste.superior_esquerdo = p_origem;
    r_teste.inferior_direito.x = 100.0;
    r_teste.inferior_direito.y = 50.0;
    r_teste.nome = "Área de Teste";
    
    // Chamando uma função que recebe struct
    float area = calcularAreaRetangulo(r_teste);
    print("A área do '", r_teste.nome, "' é:", area);

    // Chamando um método vinculado com 'bind'
    Circulo c;
    c.raio = 10.0;
    print("A área do círculo de raio 10 é:", c.area());

    // Usando vetores e seus métodos
    string cores[];
    cores.append("vermelho");
    cores.append("verde");
    cores.append("azul");
    print("Tamanho do vetor de cores:", cores.len());
    print("Cor no índice 0:", cores[0]);
    cores.remove(1); // Remove "verde"
    print("Cor no índice 1 após remoção:", cores[1]); // Agora é "azul"
    print("Novo tamanho:", cores.len());

    // Matriz (vetor de vetores)
    int matriz[][];
    matriz.append([1, 2, 3]);
    matriz.append([4, 5, 6]);
    print("Elemento da matriz [1][2] é:", matriz[1][2]);


    // --- 3.5. Comandos Especiais ---
    print("\n--- Seção 5: Comandos Especiais ---");
    
    // Comando 'wheeldecide' (wd)
    int chance = 50;
    wd {
        opt chance > 25 -> print("WD: A chance é maior que 25!");
        opt chance > 75 -> print("WD: A chance é maior que 75 (não será escolhida).");
    }

    // Laço 'do-wd'
    int contador_dowd = 2;
    do wd {
        opt contador_dowd > 0 -> {
            print("Executando o DO-WD, contador =", contador_dowd);
            contador_dowd--;
        }
    }

    // Retorno de função (return null para sair do main)
    print("\n--- FIM DA EXECUÇÃO ---");
    return null;
}